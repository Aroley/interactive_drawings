<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Projection</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
      }
    </style>
  </head>

  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.157/build/three.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>

    <script>
      const socket = io();
      const scene = new THREE.Scene();

      const camera = new THREE.OrthographicCamera(
        window.innerWidth / -2,
        window.innerWidth / 2,
        window.innerHeight / 2,
        window.innerHeight / -2,
        1,
        1000
      );
      camera.position.z = 10;

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0.15);
      renderer.autoClear = false;
      document.body.appendChild(renderer.domElement);

      window.addEventListener("resize", () => {
        camera.left = window.innerWidth / -2;
        camera.right = window.innerWidth / 2;
        camera.top = window.innerHeight / 2;
        camera.bottom = window.innerHeight / -2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      const drawings = [];
      const MAX_DRAWINGS = 30;

      // ── Receive drawing from tablet ────────────────────────────────────────
      // Payload is now { imageData, throwSpeed } instead of a raw string

      socket.on("newDrawing", ({ imageData, throwSpeed }) => {
        const loader = new THREE.TextureLoader();

        loader.load(imageData, (texture) => {
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;

          // ✅ texture.image dimensions are valid inside the callback
          const baseSize = 360;
          const aspect = texture.image.width / texture.image.height;
          const geometry = new THREE.PlaneGeometry(baseSize * aspect, baseSize);

          const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            opacity: 0.9,
          });

          const mesh = new THREE.Mesh(geometry, material);

          // Start just below the bottom of the screen, slightly random x
          // so multiple fast draws don't perfectly stack
          mesh.position.set(
            (Math.random() - 0.5) * window.innerWidth * 0.5,
            -window.innerHeight / 2 - 200,
            0
          );

          // Scale throw speed (px/ms) → scene units/frame
          // Typical swipe: 0.3–1.5 px/ms → we want vy 4–14
          const vy = Math.min(Math.max(throwSpeed * 8, 4), 14);

          mesh.userData = {
            vx: (Math.random() - 0.5) * 1.5,
            vy: vy,                          // strong upward velocity from throw
            wobble: Math.random() * Math.PI * 2,
            launched: true,                  // in "throw arc" phase
          };

          scene.add(mesh);
          drawings.push(mesh);

          if (drawings.length > MAX_DRAWINGS) {
            const old = drawings.shift();
            scene.remove(old);
            old.geometry.dispose();
            old.material.map.dispose();
            old.material.dispose();
          }
        });
      });

      // ── Animation loop ─────────────────────────────────────────────────────

      function animate() {
        requestAnimationFrame(animate);
        renderer.clearDepth();

        const t = performance.now() * 0.001;

        drawings.forEach((d) => {
          if (d.userData.launched) {
            // Gravity-like deceleration during the throw arc
            d.userData.vy -= 0.12;
            d.position.x += d.userData.vx;
            d.position.y += d.userData.vy;

            // Hand off to gentle float once the throw energy is spent
            if (Math.abs(d.userData.vy) < 1.5) {
              d.userData.launched = false;
              d.userData.vy = (Math.random() - 0.5) * 1.5;
            }
          } else {
            // Normal gentle floating
            d.position.x += d.userData.vx;
            d.position.y += d.userData.vy;
            d.position.y += Math.sin(t + d.userData.wobble) * 0.3;
          }

          // Wrap around edges so drawings never fully disappear
          if (
            Math.abs(d.position.x) > window.innerWidth / 2 + 200 ||
            Math.abs(d.position.y) > window.innerHeight / 2 + 200
          ) {
            d.position.x *= -1;
            d.position.y *= -1;
          }
        });

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
