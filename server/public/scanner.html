<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Scanner (keep this tab open)</title>
    <style>
      body {
        background: #111;
        color: #0f0;
        font-family: monospace;
        padding: 20px;
      }
      h2 {
        color: #0f0;
        margin-bottom: 4px;
      }
      .sub {
        color: #666;
        font-size: 13px;
        margin: 0 0 20px;
      }
      #log {
        font-size: 13px;
        line-height: 1.7;
        max-height: 80vh;
        overflow-y: auto;
      }
      .pass {
        color: #0f0;
      }
      .fail {
        color: #f55;
      }
      .info {
        color: #888;
      }
      #status {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 99px;
        font-size: 12px;
        margin-bottom: 16px;
        background: rgba(239, 68, 68, 0.15);
        color: #f55;
        border: 1px solid rgba(239, 68, 68, 0.3);
      }
      #status.online {
        background: rgba(34, 197, 94, 0.15);
        color: #0f0;
        border-color: rgba(34, 197, 94, 0.3);
      }
    </style>
  </head>
  <body>
    <h2>ğŸ” Shape Scanner</h2>
    <div id="status">â— disconnected</div>
    <p class="sub">Phallic shape detection only â€” OCR runs server-side.</p>
    <div id="log"></div>

    <script src="/socket.io/socket.io.js"></script>
    <canvas id="work" style="display: none"></canvas>

    <script>
      const socket = io();
      const logEl = document.getElementById("log");
      const statusEl = document.getElementById("status");
      const work = document.getElementById("work");
      const wctx = work.getContext("2d", { willReadFrequently: true });

      socket.on("connect", () => {
        socket.emit("register", "scanner");
        statusEl.textContent = "â— connected";
        statusEl.classList.add("online");
        log("info", "Connected to server âœ“");
      });

      socket.on("disconnect", () => {
        statusEl.textContent = "â— disconnected";
        statusEl.classList.remove("online");
        log("info", "Disconnected from server");
      });

      // â”€â”€ Shape scan request â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      socket.on("scanThis", async ({ scanId, imageData }) => {
        log("info", `Shape-scanning ${scanId}â€¦`);
        const reasons = [];

        try {
          const img = await loadImage(imageData);
          work.width = img.naturalWidth || img.width;
          work.height = img.naturalHeight || img.height;
          wctx.clearRect(0, 0, work.width, work.height);
          wctx.drawImage(img, 0, 0);
          const pixels = wctx.getImageData(0, 0, work.width, work.height);

          const phallicFlag = checkPhallic(pixels, work.width, work.height);
          if (phallicFlag) reasons.push(phallicFlag);
        } catch (err) {
          log("info", `Error during shape scan (${scanId}): ${err.message}`);
        }

        socket.emit("shapeResult", { scanId, reasons });

        reasons.length === 0
          ? log("pass", `âœ“ ${scanId} â€” shape clean`)
          : log("fail", `âœ— ${scanId} â€” ${reasons.join("; ")}`);
      });

      // â”€â”€ Shared ink-mask builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function buildInkMask(pixels, W, H) {
        const { data } = pixels;
        const ink = new Uint8Array(W * H);
        let count = 0;
        for (let i = 0; i < W * H; i++) {
          const r = data[i * 4],
            g = data[i * 4 + 1],
            b = data[i * 4 + 2],
            a = data[i * 4 + 3];
          if (a > 20 && !(r > 230 && g > 230 && b > 230)) {
            ink[i] = 1;
            count++;
          }
        }
        return { ink, count };
      }

      function inkBounds(ink, W, H) {
        let minX = W,
          maxX = 0,
          minY = H,
          maxY = 0;
        for (let y = 0; y < H; y++) {
          for (let x = 0; x < W; x++) {
            if (ink[y * W + x]) {
              if (x < minX) minX = x;
              if (x > maxX) maxX = x;
              if (y < minY) minY = y;
              if (y > maxY) maxY = y;
            }
          }
        }
        return {
          minX,
          maxX,
          minY,
          maxY,
          bW: maxX - minX + 1,
          bH: maxY - minY + 1,
        };
      }

      // â”€â”€ Phallic shape detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Enhanced detection: looks for tall, cylindrical shapes with rounded tip
      // and optional testicles (exactly 2 rounded lobes) at the base
      function checkPhallic(pixels, W, H) {
        const { ink, count } = buildInkMask(pixels, W, H);
        if (count < 500) return null;

        const { minX, maxX, minY, maxY, bW, bH } = inkBounds(ink, W, H);
        if (bW < 5 || bH < 5) return null;

        const aspect = bH / bW;
        // Must be taller than wide (portrait orientation)
        if (aspect < 1.3) return null;

        // Divide into horizontal bands to analyze width profile
        const BANDS = 20;
        const bandH = bH / BANDS;
        const widths = new Array(BANDS).fill(0);

        for (let b = 0; b < BANDS; b++) {
          const y0 = Math.round(minY + b * bandH);
          const y1 = Math.round(minY + (b + 1) * bandH);
          let left = W,
            right = 0,
            found = false;
          for (let y = y0; y < Math.min(y1, H); y++) {
            for (let x = minX; x <= maxX; x++) {
              if (ink[y * W + x]) {
                if (x < left) left = x;
                if (x > right) right = x;
                found = true;
              }
            }
          }
          widths[b] = found ? right - left + 1 : 0;
        }

        const maxW = Math.max(...widths) || 1;
        const normW = widths.map((w) => w / maxW);

        // Leftâ€“right symmetry check
        const cx = (minX + maxX) / 2;
        let symScore = 0,
          symCount = 0;
        for (let y = minY; y <= maxY; y++) {
          let sumX = 0,
            cnt = 0;
          for (let x = minX; x <= maxX; x++) {
            if (ink[y * W + x]) {
              sumX += x;
              cnt++;
            }
          }
          if (cnt > 0) {
            symScore += 1 - Math.abs(sumX / cnt - cx) / (bW / 2);
            symCount++;
          }
        }
        const symmetry = symCount > 0 ? symScore / symCount : 0;

        // Profile analysis
        const tipBands = normW.slice(0, 3); // Top 15%
        const shaftBands = normW.slice(3, 15); // Middle 60%
        const baseBands = normW.slice(15); // Bottom 25%

        const avgTip = avg(tipBands);
        const avgShaft = avg(shaftBands);
        const avgBase = avg(baseBands);

        // Check for testicles: base should be wider than shaft
        const hasWiderBase = avgBase > avgShaft * 1.15;

        // â”€â”€ Detect exactly 2 rounded lobes at bottom (testicles) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const hasTwoLobes = detectTwoLobes(ink, W, H, minX, maxX, minY, maxY);

        // Shaft consistency (should be cylindrical)
        const shaftVariance = variance(shaftBands);

        // Scoring criteria (need 4 out of 7 to flag)
        const criteria = [
          avgTip < avgShaft * 0.8, // Tip narrower than shaft
          shaftVariance < 0.08, // Shaft is consistent (cylindrical)
          symmetry > 0.65, // Leftâ€“right symmetric
          aspect > 1.6, // Tall and narrow
          avgShaft > 0.5, // Shaft has substance
          hasWiderBase || avgBase > 0.4, // Base present
          hasTwoLobes, // Exactly 2 rounded shapes at bottom
        ];

        const score = criteria.filter(Boolean).length;

        // Flag if 4 or more criteria met
        if (score >= 4) {
          const details = [];
          details.push(`aspect ${aspect.toFixed(1)}`);
          details.push(`sym ${(symmetry * 100).toFixed(0)}%`);
          if (hasWiderBase) details.push("wide-base");
          if (hasTwoLobes) details.push("2-lobes");
          return `phallic shape (${score}/7: ${details.join(", ")})`;
        }

        return null;
      }

      // â”€â”€ Detect exactly two rounded lobes at the bottom â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Uses connected component labeling to find distinct ink regions in the
      // bottom 30% of the bounding box, then checks if exactly 2 are found
      // and if they're roughly the same size and roundish
      function detectTwoLobes(ink, W, H, minX, maxX, minY, maxY) {
        const bW = maxX - minX + 1;
        const bH = maxY - minY + 1;

        // Focus on bottom 30% of the drawing
        const baseStartY = Math.round(maxY - bH * 0.3);
        if (baseStartY >= maxY) return false;

        // Build a mini binary image of just the base region
        const baseH = maxY - baseStartY + 1;
        const baseW = bW;
        const baseMask = new Uint8Array(baseW * baseH);

        for (let y = baseStartY; y <= maxY; y++) {
          for (let x = minX; x <= maxX; x++) {
            if (ink[y * W + x]) {
              const localY = y - baseStartY;
              const localX = x - minX;
              baseMask[localY * baseW + localX] = 1;
            }
          }
        }

        // Connected components labeling (flood fill)
        const labels = new Int32Array(baseW * baseH);
        let nextLabel = 1;
        const components = [];

        for (let y = 0; y < baseH; y++) {
          for (let x = 0; x < baseW; x++) {
            const idx = y * baseW + x;
            if (baseMask[idx] === 1 && labels[idx] === 0) {
              // Flood fill this component
              const pixels = floodFill(
                baseMask,
                labels,
                baseW,
                baseH,
                x,
                y,
                nextLabel,
              );
              components.push({ label: nextLabel, pixels, x, y });
              nextLabel++;
            }
          }
        }

        // Need exactly 2 components
        if (components.length !== 2) return false;

        // Both components should be roughly similar in size (within 3x of each other)
        const [c1, c2] = components;
        const sizeRatio =
          Math.max(c1.pixels.length, c2.pixels.length) /
          Math.min(c1.pixels.length, c2.pixels.length);
        if (sizeRatio > 3) return false;

        // Each component should be reasonably round (not super elongated)
        const isRound = (comp) => {
          let minX = baseW,
            maxX = 0,
            minY = baseH,
            maxY = 0;
          for (const [px, py] of comp.pixels) {
            if (px < minX) minX = px;
            if (px > maxX) maxX = px;
            if (py < minY) minY = py;
            if (py > maxY) maxY = py;
          }
          const w = maxX - minX + 1;
          const h = maxY - minY + 1;
          const aspectRatio = Math.max(w, h) / Math.min(w, h);
          return aspectRatio < 2.5; // Not too elongated
        };

        return isRound(c1) && isRound(c2);
      }

      // Flood fill helper for connected component labeling
      function floodFill(mask, labels, W, H, startX, startY, label) {
        const stack = [[startX, startY]];
        const pixels = [];

        while (stack.length > 0) {
          const [x, y] = stack.pop();
          const idx = y * W + x;

          if (x < 0 || x >= W || y < 0 || y >= H) continue;
          if (mask[idx] === 0 || labels[idx] !== 0) continue;

          labels[idx] = label;
          pixels.push([x, y]);

          // 4-connected neighbors
          stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
        }

        return pixels;
      }

      // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      function avg(arr) {
        return arr.reduce((a, b) => a + b, 0) / (arr.length || 1);
      }
      function variance(arr) {
        const m = avg(arr);
        return avg(arr.map((x) => (x - m) ** 2));
      }

      function loadImage(src) {
        return new Promise((res, rej) => {
          const img = new Image();
          img.onload = () => res(img);
          img.onerror = () => rej(new Error("Image load failed"));
          img.src = src;
        });
      }

      function log(cls, msg) {
        const line = document.createElement("div");
        line.className = cls;
        line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        logEl.prepend(line);
        while (logEl.children.length > 200) logEl.removeChild(logEl.lastChild);
      }
    </script>
  </body>
</html>
